`timescale 1ns/1ps
module top(
    input  wire clk,
    input  wire [3:0] btn,
    input  wire [3:0] sw,
    
    output wire [7:0] seg,
    output wire [7:0] an
    
);
     reg  [7:0] total_price;
    reg  [7:0] paid_amount;
     reg  [7:0] change_amount;
      reg  [7:0] led;
    // ------------------------
    // 1. 按键消抖
    // ------------------------
    wire [3:0] btn_pulse;

    key db0(.clk(clk), .btn_in(btn[0]), .btn_pulse(btn_pulse[0]));
    key db1(.clk(clk), .btn_in(btn[1]), .btn_pulse(btn_pulse[1]));
    key db2(.clk(clk), .btn_in(btn[2]), .btn_pulse(btn_pulse[2]));
    key db3(.clk(clk), .btn_in(btn[3]), .btn_pulse(btn_pulse[3]));

    // ------------------------
    // 2. 状态机
    // ------------------------
    localparam IDLE=3'd0, PROD1_SEL=3'd1, QTY1_SEL=3'd2,
               PROD2_SEL=3'd3, QTY2_SEL=3'd4, PAYMENT=3'd5, CHANGE=3'd6;
    reg [2:0] state, next_state;

    // ------------------------
    // 3. 商品选择和数量    
    // ------------------------
    reg [3:0] prod1_id, prod2_id;
    reg [1:0] qty1, qty2;
    reg prod1_locked, qty1_locked;
    reg prod2_locked, qty2_locked;

    reg [15:0] computed_total;

    // ------------------------
    // 初始化所有寄存器
    // ------------------------
    initial begin
        state = IDLE;
        next_state = IDLE;
        prod1_id = 0; prod2_id = 0;
        qty1 = 0; qty2 = 0;
        prod1_locked = 0; qty1_locked = 0;
        prod2_locked = 0; qty2_locked = 0;
        total_price = 0; paid_amount = 0; change_amount = 128;
        led = 8'b00000001;
    end

    // ------------------------
    // 状态转移
    // ------------------------
    always @(*) begin
        next_state = state; // 默认保持当前状态
        case(state)
            IDLE: if(btn_pulse[0]) next_state=PROD1_SEL;
            PROD1_SEL: if(btn_pulse[2]) next_state=IDLE;
                       else if(prod1_locked && btn_pulse[0]) next_state=QTY1_SEL;
            QTY1_SEL: if(btn_pulse[2]) next_state=IDLE;
                      else if(qty1_locked && btn_pulse[0]) next_state=PROD2_SEL;
            PROD2_SEL: if(btn_pulse[2]) next_state=IDLE;
                       else if(prod2_locked && btn_pulse[0]) next_state=QTY2_SEL;
                       else if(!prod2_locked && btn_pulse[0]) next_state=PAYMENT;
            QTY2_SEL: if(btn_pulse[2]) next_state=IDLE;
                      else if(qty2_locked && btn_pulse[0]) next_state=PAYMENT;
            PAYMENT: if(btn_pulse[2]) next_state=IDLE;
                     else if((paid_amount >= total_price) && btn_pulse[0]) next_state=CHANGE;
                     else if(btn_pulse[3]) next_state = IDLE;
            CHANGE: if(change_amount == 0 && btn_pulse[3]) next_state=IDLE;
            default: next_state=IDLE;
        endcase
    end

    // ------------------------
    // 商品价格查表
    // ------------------------
    function [7:0] get_price;
        input [3:0] pid;
        begin
            case(pid)
                4'h0: get_price=3; 4'h1: get_price=4; 4'h2: get_price=6; 4'h3: get_price=3;
                4'h4: get_price=10;4'h5: get_price=8; 4'h6: get_price=9; 4'h7: get_price=7;
                4'h8: get_price=4; 4'h9: get_price=6; 4'hA: get_price=15;4'hB: get_price=8;
                4'hC: get_price=9; 4'hD: get_price=4; 4'hE: get_price=5; 4'hF: get_price=5;
                default: get_price=0;
            endcase
        end
    endfunction

function [7:0] get_id;
        input [3:0] prod;
        begin
            case(prod)
                4'h0: get_id=11; 4'h1: get_id=12; 4'h2: get_id=13; 4'h3: get_id=14;
                4'h4: get_id=21;4'h5: get_id=22; 4'h6: get_id=23; 4'h7: get_id=24;
                4'h8: get_id=31; 4'h9: get_id=32; 4'hA: get_id=33;4'hB: get_id=34;
                4'hC: get_id=41; 4'hD: get_id=42; 4'hE: get_id=43; 4'hF: get_id=44;
                default: get_id=0;
            endcase
        end
    endfunction

    // ------------------------
    // 总价计算
    // ------------------------
    always @(*) begin
        computed_total = 0;
        if(prod1_locked && qty1_locked) computed_total = computed_total + get_price(prod1_id)*qty1;
        if(prod2_locked && qty2_locked) computed_total = computed_total + get_price(prod2_id)*qty2;
    end

    // ------------------------
    // 状态寄存器和交易逻辑
    // ------------------------
    always @(posedge clk) begin
        state <= next_state;

        if(btn_pulse[2]) begin
            // 取消按钮按下，重置所有状态
            state <= IDLE;
            prod1_id <= 0; prod2_id <= 0;
            qty1 <= 0; qty2 <= 0;
            prod1_locked <= 0; qty1_locked <= 0;
            prod2_locked <= 0; qty2_locked <= 0;
            total_price <= 0; paid_amount <= 0; change_amount <= 128;
            led <= 8'b00000001;
        end else begin
            case(state)
                PROD1_SEL: if(btn_pulse[1]) begin 
                    prod1_id <= sw[3:0];
                    
                    prod1_locked <= 1'b1;
                end
                
                QTY1_SEL: if(btn_pulse[1] && sw[1:0] != 0) begin 
                    qty1 <= sw[1:0]; 
                    qty1_locked <= 1'b1;
                end
                
                PROD2_SEL: if(btn_pulse[1]) begin 
                    prod2_id <= sw[3:0];
             
                    prod2_locked <= 1'b1;
                end
                
                QTY2_SEL: if(btn_pulse[1] && sw[1:0] != 0) begin 
                    qty2 <= sw[1:0]; 
                    qty2_locked <= 1'b1;
                end
                
                PAYMENT: if(btn_pulse[1]) begin
                    if(sw[0] == 0) paid_amount <= paid_amount + 1;
                    else case(sw[2:1])
                        2'b00: paid_amount <= paid_amount + 5;
                        2'b01: paid_amount <= paid_amount + 10;
                        2'b10: paid_amount <= paid_amount + 20;
                        2'b11: paid_amount <= paid_amount + 50;
                    endcase
                end
                
                CHANGE: begin
                    if(change_amount == 128 && paid_amount >= total_price)
                        change_amount <= paid_amount - total_price;
                    else if(btn_pulse[3] && change_amount > 0)
                        change_amount <= change_amount - 1;
                end
            endcase
            
            if(state != IDLE) 
                total_price <= computed_total[7:0];
        end
    end

    // ------------------------
    // LED 状态指示
    // ------------------------
    always @(*) begin
        case(state)
            IDLE: led = 8'b00000001;
            PROD1_SEL: led = 8'b00000010;
            QTY1_SEL: led = 8'b00000100;
            PROD2_SEL: led = 8'b00001000;
            QTY2_SEL: led = 8'b00010000;
            PAYMENT: led = 8'b00100000;
            CHANGE: led = 8'b01000000;
            default: led = 8'b00000000;
        endcase
    end

    // ------------------------
    // 4. 7-Segment 显示
    // ------------------------
    reg [3:0] seg_buffer0, seg_buffer1, seg_buffer2, seg_buffer3;
    reg [3:0] seg_buffer4, seg_buffer5, seg_buffer6, seg_buffer7;
    reg [2:0] scan_idx;
    reg [7:0] seg_out, an_out;

    // 显示逻辑
    always @(*) begin
        // 默认清零所有显示位
        seg_buffer0 = 4'b0; seg_buffer1 = 4'b0; seg_buffer2 = 4'b0; seg_buffer3 = 4'b0;
        seg_buffer4 = 4'b0; seg_buffer5 = 4'b0; seg_buffer6 = 4'b0; seg_buffer7 = 4'b0;

        case(state)
            PROD1_SEL: begin
                seg_buffer0 = get_id(prod1_id)/10 ;
                seg_buffer1 = get_id(prod1_id)%10  ;
            end
            
            QTY1_SEL: begin
                seg_buffer0 = get_id(prod1_id)/10 ;
                seg_buffer1 = get_id(prod1_id)%10  ;
                seg_buffer2 = qty1 / 10;
                seg_buffer3 = qty1 % 10;
            end
            
            PROD2_SEL: begin
                seg_buffer0 = get_id(prod2_id)/10;
                seg_buffer1 = get_id(prod2_id)%10;
            end
            
            QTY2_SEL: begin
               seg_buffer0 = get_id(prod2_id)/10;
                seg_buffer1 = get_id(prod2_id)%10;
                seg_buffer2 = qty2 / 10;
                seg_buffer3 = qty2 % 10;
            end

            PAYMENT: begin
                seg_buffer2 = paid_amount / 10;
                seg_buffer3 = paid_amount % 10;
                seg_buffer0 = total_price / 10;
                seg_buffer1 = total_price % 10;
            end

            CHANGE: begin
                seg_buffer0 = change_amount / 10;
                seg_buffer1 = change_amount % 10;
            end
        endcase
    end

    // 7-seg 扫描输出
    reg [13:0] div_cnt;  // 足够存储到12500
always @(posedge clk) begin
    if(div_cnt >= 12500-1) begin
        div_cnt  <= 0;
        scan_idx <= scan_idx + 1;  // 切换到下一位
    end else begin
        div_cnt <= div_cnt + 1;
    end
end


    // 数码管选择逻辑
    always @(*) begin
        //an_out = 8'hFF;
        case(scan_idx)
            3'd0: begin seg_out = bcd2seg(seg_buffer0);an_out=8'b11111110;end
            3'd1: begin seg_out = bcd2seg(seg_buffer1);an_out=8'b11111101;end
            3'd2: begin seg_out = bcd2seg(seg_buffer2);an_out=8'b11111011;end
            3'd3: begin seg_out = bcd2seg(seg_buffer3);an_out=8'b11110111;end
            3'd4: begin seg_out = bcd2seg(seg_buffer4);an_out=8'b11101111;end
            3'd5: begin seg_out = bcd2seg(seg_buffer5);an_out=8'b11011111;end
            3'd6: begin seg_out = bcd2seg(seg_buffer6);an_out=8'b10111111;end
            3'd7: begin seg_out = bcd2seg(seg_buffer7);an_out=8'b01111111;end
            default: seg_out = 8'b11111111;
        endcase
        //an_out[scan_idx] = 0;
    end

    assign seg = seg_out;
    assign an = an_out;

    // BCD->7-seg 映射
    function [7:0] bcd2seg;
        input [3:0] bcd;
        begin
            case(bcd)
                4'd0: bcd2seg = 8'b11000000;
                4'd1: bcd2seg = 8'b11111001;
                4'd2: bcd2seg = 8'b10100100;
                4'd3: bcd2seg = 8'b10110000;
                4'd4: bcd2seg = 8'b10011001;
                4'd5: bcd2seg = 8'b10010010;
                4'd6: bcd2seg = 8'b10000010;
                4'd7: bcd2seg = 8'b11111000;
                4'd8: bcd2seg = 8'b10000000;
                4'd9: bcd2seg = 8'b10010000;
                default: bcd2seg = 8'b11111111;
            endcase
        end
    endfunction

endmodule

module key #(
    parameter DEBOUNCE_CYCLES = 30000  // 20ms for 50MHz
)(
    input  wire clk,
    input  wire btn_in,     // 低电平有效输入
    output wire btn_pulse   // 下降沿脉冲输出
);

    reg [19:0] counter = 0;
    reg btn_prev1 = 1'b1;
    reg btn_prev2 = 1'b1;
    reg btn_stable = 1'b1;
    reg btn_stable_prev = 1'b1;

    // 同步器
    always @(posedge clk) begin
        btn_prev1 <= btn_in;
        btn_prev2 <= btn_prev1;
    end

    // 消抖逻辑
    always @(posedge clk) begin
        btn_stable_prev <= btn_stable;
        
        if (btn_prev2 != btn_stable) begin
            if (counter < DEBOUNCE_CYCLES) begin
                counter <= counter + 1;
            end else begin
                btn_stable <= btn_prev2;
                counter <= 0;
            end
        end else begin
            counter <= 0;
        end
    end

    // 检测下降沿：从高电平(松开)变为低电平(按下)
    assign btn_pulse = (btn_stable_prev == 1'b1) && (btn_stable == 1'b0);

endmodule

